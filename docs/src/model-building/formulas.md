# `@formulas`

The `@formulas` block specifies the observation model that links latent quantities to measured data. It defines deterministic intermediate expressions and the statistical distributions assumed for each observed outcome. Within `@Model`, this block is required.

## Core Syntax

Two statement forms are supported inside `@formulas`:

- **Deterministic assignment:** `name = expression` defines an intermediate quantity computed from model components.
- **Observation definition:** `name ~ distribution_expression` declares a likelihood contribution for a named outcome column.

```julia
form = @formulas begin
    lin = a + eta^2 + x.Age
    y ~ Laplace(lin, sigma)
end
```

## Parsing and Validation Rules

The macro enforces the following constraints at model-construction time:

- The block must use `begin ... end` syntax.
- Only assignments (`=`) and observation statements (`~`) are permitted.
- The left-hand side of each statement must be a plain symbol.
- The reserved symbols `t` and `ξ` cannot appear on the left-hand side.
- Duplicate names within deterministic definitions, within observation definitions, or across both categories are rejected.

## Symbol Resolution and Namespace Rules

Expressions inside `@formulas` can reference symbols drawn from several model namespaces:

- Fixed effects
- Random effects
- PreDE outputs
- Constant covariates
- Varying covariates
- Helper functions (`@helpers`)
- Model functions from learned parameter blocks (e.g., neural networks, soft trees)

If a symbol name is shared across more than one namespace among fixed effects, random effects, preDE outputs, and covariates, the macro raises an ambiguity error to prevent silent resolution conflicts.

## State and Signal Access from ODE Models

When the model includes a differential equation system, ODE states and derived signals can be referenced in formulas subject to the following rules:

- States and signals must be called with an explicit time argument, e.g., `x1(t)` or `s(t)`.
- Bare references without a time argument (e.g., `x1`, `s`) are rejected.
- The set of required states and signals is inferred automatically and stored as `required_states` and `required_signals`.

At runtime, formulas that depend on ODE outputs receive solution accessor functions generated by `get_de_accessors_builder(...)`.

## Time Offsets in State and Signal Calls

Formulas support constant time offsets when accessing ODE states and signals, enabling evaluation at shifted time points:

- `x1(t + 0.25)`
- `x1(t - 0.5)`
- `x1(t + (1/4))`

These offsets are exposed through `get_formulas_time_offsets(...)` and handled automatically during `DataModel` construction:

- Constant offsets extend the integration window and save grid as needed.
- Negative offsets that would require evaluation before the start of an individual's trajectory are rejected.
- Non-constant offsets (e.g., expressions involving covariates) require dense ODE solving mode.

## Example: Multiple Deterministic Nodes and Outcomes

The following model illustrates the use of multiple intermediate deterministic expressions feeding into two distinct outcome distributions.

```julia
using NoLimits
using Distributions

model = @Model begin
    @fixedEffects begin
        a = RealNumber(0.2)
        b = RealNumber(0.1)
        s1 = RealNumber(0.3, scale=:log)
        s2 = RealNumber(0.4, scale=:log)
    end

    @covariates begin
        t = Covariate()
        x = ConstantCovariateVector([:Age, :BMI]; constant_on=:ID)
    end

    @randomEffects begin
        eta = RandomEffect(TDist(6.0); column=:ID)
    end

    @formulas begin
        d1 = a + 0.01 * x.Age^2 + tanh(eta)
        d2 = d1 + b * log1p(x.BMI^2) + eta^2
        y1 ~ LogNormal(d2, s1)
        y2 ~ Gamma(d1^2 + abs(eta) + 1e-6, s2)
    end
end
```

## Example: Helper Functions and Learned Model Functions

User-defined helpers and learned parameter blocks (such as neural networks) can be called directly within formula expressions.

```julia
using NoLimits
using Distributions
using Lux

chain = Chain(Dense(2, 4, tanh), Dense(4, 1))

model = @Model begin
    @helpers begin
        softplus(u) = log1p(exp(u))
    end

    @fixedEffects begin
        sigma = RealNumber(0.4, scale=:log)
        z = NNParameters(chain; function_name=:NN1, calculate_se=false)
    end

    @covariates begin
        t = Covariate()
        x = ConstantCovariateVector([:Age, :BMI]; constant_on=:ID)
    end

    @randomEffects begin
        eta = RandomEffect(SkewNormal(0.0, 1.0, 0.8); column=:ID)
    end

    @formulas begin
        lin = NN1([x.Age, x.BMI], z)[1] + softplus(eta^2)
        y ~ Gamma(lin + 1e-6, sigma)
    end
end
```

## Example: ODE State and Signal Access

When a model includes `@DifferentialEquation`, states and derived signals are accessed in formulas using explicit time arguments. Time offsets such as `x1(t + 0.25)` enable evaluation at shifted time points.

```julia
using NoLimits
using Distributions

model = @Model begin
    @fixedEffects begin
        a = RealNumber(0.2)
        sigma = RealNumber(0.3, scale=:log)
    end

    @covariates begin
        t = Covariate()
    end

    @DifferentialEquation begin
        s(t) = sin(t)
        D(x1) ~ -a * x1 + s(t)
    end

    @initialDE begin
        x1 = 1.0
    end

    @formulas begin
        mu = x1(t) + s(t) + x1(t + 0.25)
        y ~ Exponential(log1p(abs(mu)) + 1e-6)
    end
end
```

## Example: Hidden Markov Observation Model

For data generated by regime-switching processes, `@formulas` supports hidden Markov model likelihoods via `ContinuousTimeDiscreteStatesHMM`. The transition rate matrix, per-state emission distributions, initial state distribution, and inter-observation time intervals are specified directly.

```julia
using NoLimits
using Distributions

model = @Model begin
    @fixedEffects begin
        λ12 = RealNumber(0.2, scale=:log)
        λ21 = RealNumber(0.3, scale=:log)
        p1 = RealNumber(0.25)
        p2 = RealNumber(0.75)
    end

    @covariates begin
        t = Covariate()
        delta_t = Covariate()
    end

    @formulas begin
        outcome ~ ContinuousTimeDiscreteStatesHMM(
            [-λ12  λ12;
              λ21 -λ21],
            (Bernoulli(p1), Bernoulli(p2)),
            Categorical([0.6, 0.4]),
            delta_t
        )
    end
end
```

## Related APIs

The following functions provide programmatic access to the internal representation and evaluation of formulas:

- `get_formulas_meta(formulas)`
- `get_formulas_ir(formulas)`
- `get_formulas_builders(formulas; ...)`
- `get_formulas_all(formulas, ctx, sol_accessors, constant_covariates_i, varying_covariates; ...)`
- `get_formulas_obs(formulas, ctx, sol_accessors, constant_covariates_i, varying_covariates; ...)`
- `get_formulas_time_offsets(formulas, state_names, signal_names)`
